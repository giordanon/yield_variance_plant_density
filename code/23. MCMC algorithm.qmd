---
title: "Untitled"
format: html
editor: visual
---

```{r include = FALSE}
library(tidyverse)
```


```{r}
data_mh <- readRDS("../data/data_ye2.RData") %>% 
  filter(SOURCE2 == "Kansas" & TRT2 == "Treated" & CLEAN2 == "Heavy" & YE2 == 3.37) %>% 
  dplyr::select(YIELD, STAND) %>% 
  ungroup() 

plot(data_mh$STAND, data_mh$YIELD)
```

# Update 5 parameters at the same time

```{r}
i=1
# Preliminary steps
x <- data_mh$STAND
y <- data_mh$YIELD

iterations <- 1000

parameterName <- c("b1", "AOPD", "a1", "maxVPD", "minVPD")
parameterStart <- c(0.05,150,0.020,105,300)
sigmaTune <- c(0.005,10, 0.005,10,10)

```

```{r}

# Process model for the mean
quad_plateau <- function(b1, AOPD,x){
  y  = ifelse(x > AOPD,
              b1*AOPD+(-b1/(2*AOPD))*AOPD^2,
              # else
              b1*x+(-b1/(2*AOPD))*x^2)
  
  return(y)
  }

#Process Model for the variance
exp_plateau <- function(a1, maxVPD,minVPD,x){
  a2 = (-a1/(2*maxVPD))
  y = ifelse(x == 0, 0,
             ifelse(x > minVPD, 
                    exp(a1*minVPD+a2*minVPD^2),
                    # else
                    exp(a1*x+a2*x^2)))
  
  return(y)
  }

```


```{r}
# Likelihood function
likelihood <- function(parameters, 
                       x,
                       y
                       ){
  b1 = parameters[1]
  AOPD = parameters[2]
  
  a1 = parameters[3]
  maxVPD = parameters[4]
  minVPD = parameters[5]
  
  pred = quad_plateau(b1, AOPD, x) # Process model to the mean
  
  predVar <- exp_plateau(a1,maxVPD,minVPD,x) # Process model for the variance
  
  singlelikelihoods = dnorm(y, 
                            mean = pred, 
                            sd = sqrt(predVar), 
                            log = T)
  sumll = sum(singlelikelihoods)
  return(sumll)
}

```


```{r}
# Priors 
priors <- function(parameters){
  
  b1 = parameters[1]
  AOPD = parameters[2]
  
  a1 = parameters[3]
  maxVPD = parameters[4]
  minVPD = parameters[5]
  
  # Specify priors
  bprior = dunif(b1, min = 0.001, max = 0.2, log = T)
  AOPDprior = dunif(AOPD, min = 10, max = 400, log = T)
  
  aprior = dunif(a1, min = 0, max = 0.05, log = T)
  # Upper bound from Canadian data 192
  minVPDprior = dunif(minVPD, min = 10, max = 192, log = T)
  # Upper bound from Canadian data 124
  maxVPDprior = dunif(maxVPD, min = 10, max = 124, log = T)
  
  return(bprior+AOPDprior+aprior+minVPDprior+maxVPDprior)
}

```


```{r}
# Likelihood * Prior
posterior <- function(parameters,x,y){
  
  return (likelihood(parameters,x,y) + priors(parameters))
}

```


```{r}
# Proposal values
## Correlated random walk is implemented
proposalFunction <- function(paramOld){
  # Expected value
  b1.try <- rnorm(1, mean = paramOld[1], sd = sigma.tune[1])
  AOPD.try <- rnorm(1, mean = paramOld[2], sd = sigma.tune[2])
  # Variance
  a1.try <- rnorm(1, mean = paramOld[3], sd = sigma.tune[3])
  maxVPD.try <- rnorm(1, mean = paramOld[4], sd = sigma.tune[4])
  minVPD.try <- rnorm(1, mean = paramOld[5], sd = sigma.tune[5])
  
  return(c(b1.try,AOPD.try, a1.try,maxVPD.try, minVPD.try))
}

```

```{r}
# MCMC chain using metropolis hastings 
metropolisMCMC <- function(iterations,# number of iterations
                           burnIn,# burn in interval
                           thinning, # every how many samples?
                           startValue, # starting values for model parameters
                           x, 
                           y
                                ){
  # Chain for E(y)
  chain = array(dim = c(iterations+1,5))
  chain[1,] = startValue
  
  # Loop for E(y) and Var(y) together
  for (i in 1:iterations){
    
    proposal = proposalFunction(chain[i,])
    
    probability = exp(posterior(proposal,x,y) - posterior(chain[i,],x,y))
    if (runif(1) < probability){
      # Accept
      chain[i+1,] = proposal
    }else{
      # Reject
      chain[i+1,] = chain[i,]
    }
    
  }
  # Burn in interval
  burnSamples = iterations * burnIn
  chain = chain[-burnSamples,]
  # Thinning
  chain <- chain[seq(1,nrow(chain),thinning),]
  # Assign names to columns
  colnames(chain) = names(startValue)
  # MH Output
  return(chain)
}


```

```{r}
# Preliminary steps
x <- data_mh$STAND
y <- data_mh$YIELD

iterations <- 1000000
burnIn <- 0.2
thinning <- 5

parameterName <- c("b1", "AOPD", "a1", "maxVPD", "minVPD")
parameterStart <- c("b1" = 0.05,
                    "AOPD" = 150,
                    "a1" = 0.020,
                    "maxVPD" = 105,
                    "minVPD" = 150)
sigmaTune <- c(0.005,10, 0.005,10,10)

out <- metropolisMCMC(iterations,burnIn,thinning, parameterStart, x,y )

acceptance = 1-mean(duplicated(out))

length((out[,1]))

```



```{r fig.width= 20 fig.height = 7}
par(mfrow = c(2,5))
hist(out[,1],nclass=30, , main="Posterior of b1" )
hist(out[,2],nclass=30, main="Posterior of AOPD")
hist(out[,3],nclass=30, main="Posterior of a1")
hist(out[,4],nclass=30, main="Posterior of maxVPD")
hist(out[,5],nclass=30, main="Posterior of minVPD")

plot(out[,1], type = "l",  main = "Chain values of b1")
plot(out[,2], type = "l",  main = "Chain values of AOPD")
plot(out[,3], type = "l",  main = "Chain values of a1")
plot(out[,4], type = "l",  main = "Chain values of maxVPD")
plot(out[,5], type = "l",  main = "Chain values of minVPD")
```

```{r}
xl <- seq(10,200,2)
# Get prediction intervals
df_pred <- 
as.data.frame(out) %>% 
  rowwise() %>% 
  mutate(sigmaY = list(exp_plateau(a1, maxVPD, minVPD, xl)), 
         YIELD = list(quad_plateau(b1, AOPD, xl)),
         STAND = list(xl)
         ) %>% 
  rowid_to_column("draw") %>% 
  mutate(pred_int = list(pmap(list(..1 = YIELD, ..2 = sigmaY),
                         ~rnorm(1,..1, sqrt(..2))
                         )
                         )
         ) %>% 
  dplyr::select(draw, STAND, pred_int) %>% 
  unnest(cols = c(STAND, pred_int)) %>% 
  group_by(STAND) %>% 
  summarise(q050 = quantile(as.numeric(pred_int), 0.5), 
            q975 = quantile(as.numeric(pred_int), 0.975), 
            q025 = quantile(as.numeric(pred_int), 0.025)
            )  
```

```{r}
df_pred %>% 
ggplot()+
  geom_line(aes(x = STAND, y = q050), size = 1)+
  geom_line(aes(x = STAND, y = q975))+
  geom_line(aes(x = STAND, y = q025))+
  geom_ribbon(aes(x = STAND,ymin = q025, ymax = q975), alpha = 0.3, fill = "red")+
  theme_test()+
  geom_point(data = data_mh, aes(x = STAND, y = YIELD), shape = 21, fill = "#d5d8de", size = 3, alpha = .5)
```


